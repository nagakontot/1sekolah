<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - cameras</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body, html 
			{	width: 		100%;
    			height: 	100%;
    			margin: 	0;
    			padding: 	0;
			}
			
			canvas 
			{	position: 	absolute;
    			top: 		0;
    			bottom: 	0;
    			left: 		0;
    			right: 		0;
    			z-index: 	0;
			}
			
		</style>
	</head>
	
	<body>
		
		<div id="canvas"></div>
		
		<!--
		<script src="js/three_v84.min.js"></script>
		<script src="js/stats.min.js"></script>
		-->

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
		<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
		<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>

		<script>
var scene, renderer, camera, mesh;
var clock = new THREE.Clock();
var orbitcontrols;
var keyboard = new KeyboardState();

init();
render();

function init () 
{
	scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

	renderer = new THREE.WebGLRenderer();
	renderer.setClearColor(new THREE.Color(0x888888, 1.0));
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.shadowMapEnabled = true;
	document.body.appendChild (renderer.domElement);

	// position and point the camera to the center of the scene
	camera.position.x = -50;
	camera.position.y = 40;
	camera.position.z = 160;
	camera.lookAt(new THREE.Vector3(0, 0, 0));

	orbitcontrols = new THREE.OrbitControls(camera, renderer.domElement);

	// add spotlight for the shadows
	var spotLight = new THREE.SpotLight(0xffffff);
	spotLight.position.set(-50, 70, 60);
	spotLight.intensity = 1;
	scene.add(spotLight);

	var gridXZ = new THREE.GridHelper(150, 10);
	gridXZ.setColors( new THREE.Color(0xff0000), new THREE.Color(0xffffff) );
	scene.add(gridXZ);

THREE.ImageUtils.crossOrigin = '';
	var loader = new THREE.JSONLoader();
	loader.load('https://jyunming-chen.github.io/tutsplus/models/laalaa.js', function (geometry, mat) {
		geometry.computeMorphNormals();

		var mat = new THREE.MeshBasicMaterial(
				{
					map: THREE.ImageUtils.loadTexture("https://jyunming-chen.github.io/tutsplus/models/laalaa.png"),
					morphTargets: true, morphNormals: true
				});

		mesh = new THREE.MorphAnimMesh(geometry, mat);
		mesh.parseAnimations();

		mesh.playAnimation('run', 10);

		scene.add(mesh);
	});

	window.addEventListener ('resize', onWindowResize, false);	
}

function onWindowResize()
{
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize (window.innerWidth, window.innerHeight);
}

var angle=0;
var inJump = false, startJump = false;

function render() 
{
	var delta = clock.getDelta();  // in seconds
	orbitcontrols.update();
	keyboard.update();
	
	if ( keyboard.down("J") && !inJump) { // yes, must use UPPER CASE
		startJump = true;
	}
	
	angle += 0.01;
	
	if (mesh !== undefined) {
		mesh.position.x = 130*Math.cos(angle);
		mesh.position.z = - 130*Math.sin(angle);
		mesh.position.y = 25;
		mesh.rotation.y = -Math.PI/2 + angle;

		if (startJump) {
			mesh.playAnimation('jump', 10);  // slow motion jump
			// console.log (mesh.startKeyframe, " ", mesh.endKeyframe);
			inJump = true;
			startJump = false;
		}

		if (inJump && mesh.currentKeyframe == mesh.endKeyframe) { // end of jump
			mesh.playAnimation ('run', 10);						  // switch to run
			inJump = false;
		}

		// console.log (mesh.currentKeyframe);
		
		mesh.updateAnimation(delta * 1000);   // in msecs
	}

	requestAnimationFrame(render);
	renderer.render(scene, camera);
}
			
		</script>>

	</body>
</html>

<!---------------------------------------------------------------------------------->
<!---------------------------------------------------------------------------------->
<!---------------------------------------------------------------------------------->
<!---------------------------------------------------------------------------------->


<!--

		<script>
			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;
			var aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
			var container, stats;
			var camera, scene, renderer, mesh;
			var cameraRig, activeCamera, activeHelper;
			var cameraPerspective, cameraOrtho;
			var cameraPerspectiveHelper, cameraOrthoHelper;
			var frustumSize = 600;
			init();
			animate();
			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				scene = new THREE.Scene();
				//
				camera = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 1, 10000 );
				camera.position.z = 2500;
				cameraPerspective = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 150, 1000 );
				cameraPerspectiveHelper = new THREE.CameraHelper( cameraPerspective );
				scene.add( cameraPerspectiveHelper );
				//
				cameraOrtho = new THREE.OrthographicCamera( 0.5 * frustumSize * aspect / - 2, 0.5 * frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 150, 1000 );
				cameraOrthoHelper = new THREE.CameraHelper( cameraOrtho );
				scene.add( cameraOrthoHelper );
				//
				activeCamera = cameraPerspective;
				activeHelper = cameraPerspectiveHelper;
				// counteract different front orientation of cameras vs rig
				cameraOrtho.rotation.y = Math.PI;
				cameraPerspective.rotation.y = Math.PI;
				cameraRig = new THREE.Group();
				cameraRig.add( cameraPerspective );
				cameraRig.add( cameraOrtho );
				scene.add( cameraRig );
				//
				mesh = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 100, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } )
				);
				scene.add( mesh );
				var mesh2 = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 50, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } )
				);
				mesh2.position.y = 150;
				mesh.add( mesh2 );
				var mesh3 = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 5, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true } )
				);
				mesh3.position.z = 150;
				cameraRig.add( mesh3 );
				//
				var geometry = new THREE.Geometry();
				for ( var i = 0; i < 10000; i ++ ) {
					var vertex = new THREE.Vector3();
					vertex.x = THREE.Math.randFloatSpread( 2000 );
					vertex.y = THREE.Math.randFloatSpread( 2000 );
					vertex.z = THREE.Math.randFloatSpread( 2000 );
					geometry.vertices.push( vertex );
				}
				var particles = new THREE.Points( geometry, new THREE.PointsMaterial( { color: 0x888888 } ) );
				scene.add( particles );
				//
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				renderer.domElement.style.position = "relative";
				container.appendChild( renderer.domElement );
				renderer.autoClear = false;
				//
				stats = new Stats();
				container.appendChild( stats.dom );
				//
				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'keydown', onKeyDown, false );
			}
			//
			function onKeyDown ( event ) {
				switch( event.keyCode ) {
					case 79: /*O*/
						activeCamera = cameraOrtho;
						activeHelper = cameraOrthoHelper;
						break;
					case 80: /*P*/
						activeCamera = cameraPerspective;
						activeHelper = cameraPerspectiveHelper;
						break;
				}
			}
			//
			function onWindowResize( event ) {
				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;
				aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				camera.aspect = 0.5 * aspect;
				camera.updateProjectionMatrix();
				cameraPerspective.aspect = 0.5 * aspect;
				cameraPerspective.updateProjectionMatrix();
				cameraOrtho.left   = - 0.5 * frustumSize * aspect / 2;
				cameraOrtho.right  =   0.5 * frustumSize * aspect / 2;
				cameraOrtho.top    =   frustumSize / 2;
				cameraOrtho.bottom = - frustumSize / 2;
				cameraOrtho.updateProjectionMatrix();
			}
			//
			function animate() {
				requestAnimationFrame( animate );
				render();
				stats.update();
			}
			function render() {
				var r = Date.now() * 0.0005;
				mesh.position.x = 700 * Math.cos( r );
				mesh.position.z = 700 * Math.sin( r );
				mesh.position.y = 700 * Math.sin( r );
				mesh.children[ 0 ].position.x = 70 * Math.cos( 2 * r );
				mesh.children[ 0 ].position.z = 70 * Math.sin( r );
				if ( activeCamera === cameraPerspective ) {
					cameraPerspective.fov = 35 + 30 * Math.sin( 0.5 * r );
					cameraPerspective.far = mesh.position.length();
					cameraPerspective.updateProjectionMatrix();
					cameraPerspectiveHelper.update();
					cameraPerspectiveHelper.visible = true;
					cameraOrthoHelper.visible = false;
				} else {
					cameraOrtho.far = mesh.position.length();
					cameraOrtho.updateProjectionMatrix();
					cameraOrthoHelper.update();
					cameraOrthoHelper.visible = true;
					cameraPerspectiveHelper.visible = false;
				}
				cameraRig.lookAt( mesh.position );
				renderer.clear();
				activeHelper.visible = false;
				renderer.setViewport( 0, 0, SCREEN_WIDTH/2, SCREEN_HEIGHT );
				renderer.render( scene, activeCamera );
				activeHelper.visible = true;
				renderer.setViewport( SCREEN_WIDTH/2, 0, SCREEN_WIDTH/2, SCREEN_HEIGHT );
				renderer.render( scene, camera );
			}
		</script>
		
-->

