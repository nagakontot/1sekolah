<html>
  	<head>
		<title>spinnin' cubes! yes! plural!</title>
		<!--style>canvas { width: 100%; height: 100% }</style-->
		<script src="xgui.min.js"></script>
		<style type="text/css">
			#settings { text-align:right; top:8px; right:8px; position:absolute; color:#fff; background: #121212; opacity:0.8; border-radius:12px; padding: 6px }
		</style>
	
	</head>
	<body onLoad="init();">
		<div id="settings"></div>
		<!--canvas id="myCanvas" width="800" height="800" >Sorry! You need a modern browser to be able to view this.</canvas-->
		<!------------------------------------------------------------------------------------>
		
		<script>
//var context;
//var canvas;

var gui;
/*
var settings = {
	steps: 16,
	color: "840000",
	bgcolor: "eeeeee",
	startx: 200,
	starty: 400,
	endx: 600,
	endy: 400,
};
*/
function init() {

	//canvas = document.getElementById('myCanvas');
	//context = canvas.getContext('2d');

	setupGui();

	//redraw();

}

		function redraw () {
/*
	context.clearRect(0,0,800,800);

	context.fillStyle = "#"+settings.bgcolor;
	context.fillRect(0,0,800,800);

	context.strokeStyle = "#"+settings.color;
	context.lineWidth = 1;

	var startPoint = {x:settings.startx, y:settings.starty};
	var endPoint = {x:settings.endx, y:settings.endy};

	
	context.beginPath();

	//drawDragonCurve(startPoint, endPoint, Math.round(settings.steps));

    context.stroke();
    
*/
}

		function doRedraw (value, mouseup) {
	//if (mouseup) redraw();
}

		function setupGui() {
	
	gui = new xgui( {width: 190, height: 190, backgroundColor: "#dddddd", frontColor: "#444444", dimColor: "#dddddd"} );


	var settingsDiv = document.getElementById('settings');
	settingsDiv.appendChild( gui.getDomElement() );

	var label = new gui.Label( {x: 10, y: 10, text: "Steps:"} )
	var steps = new gui.HSlider( {x:80, y:10, value: settings.steps, min: 2, max: 20} );
	steps.value.bind(settings, "steps");
	steps.value.bind(doRedraw);

	var label = new gui.Label( {x: 10, y: 40, text: "Background:"} );
	var label = new gui.Label( {x: 10, y: 60, text: "Color:"} );

	var bgcolor = new gui.ColorPicker2( {x: 80, y: 40, hex: settings.bgcolor } );
	bgcolor.value.bind(settings, "bgcolor");
	bgcolor.value.bind(doRedraw);

	var color = new gui.ColorPicker2( {x: 80, y: 60, hex: settings.color } );
	color.value.bind(settings, "color");
	color.value.bind(doRedraw);
	
	var label = new gui.Label( {x: 10, y: 85, text: "Start Position"} );
	
	var start = new gui.TrackPad( {x: 10, y: 100, min: 100, max: 700, height: 70, width: 70, value1: settings.startx, value2: settings.starty } );
	start.value1.bind(settings, "startx");
	start.value2.bind(settings, "starty");
	start.value2.bind(doRedraw);

	var label = new gui.Label( {x: 110, y: 85, text: "End Position"} );
	
	var end = new gui.TrackPad( {x: 110, y: 100, min: 100, max: 700, height: 70, width: 70, value1: settings.endx, value2: settings.endy } );
	end.value1.bind(settings, "endx");
	end.value2.bind(settings, "endy");
	end.value2.bind(doRedraw);

	//var redraw = new gui.Button( {x: 10, y: 200, text: "Redraw" } );
	//redraw.value.bind(doRedraw);
	}	
		</script>
		<!------------------------------------------------------------------------------------>
		<!--
		<script src="js/three_v84.min.js"></script>
		<script src="three.portals.js"></script>
		-->
		
		<!--iframe src="https://drawonthe.net/board_index.php?id=100715_1" width="400" height="400"></iframe-->
		
		<!--iframe src="https://www.twiddla.com/tzcha7" width="800" height="600"></iframe-->
		
		<!--iframe src="https://test1.1sekolah.xyz/ViewerJS/#../pdf/test_flash.pdf" width="800" height="600" allowfullscreen webkitallowfullscreen></iframe-->
		

		<!--
		<div style="width: 100%; height: 100%;" id="aww-wrapper"></div>
    	<script src="https://awwapp.com/static/widget/js/aww.min.js"></script>
    	<script type="text/javascript">
    		var aww = new AwwBoard('#aww-wrapper', {});
    	</script>
    	-->

		<!--script>
			//create basic context
			var main_scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
			var renderer = new THREE.WebGLRenderer({stencil: true});
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			
			//create scene
			
			//create cube
			var geometry = new THREE.CubeGeometry(0.5,0.5,0.5);
			var material = new THREE.MeshPhongMaterial({color: 0x00ff00});
			var cube = new THREE.Mesh(geometry, material);
			main_scene.add(cube);
			
			//create portals
			var portal_geom = new THREE.Geometry();
			portal_geom.vertices.push( new THREE.Vector4( -1, -1) );
			portal_geom.vertices.push( new THREE.Vector4(  1, -1) );
			portal_geom.vertices.push( new THREE.Vector4( -1,  1) );
			portal_geom.vertices.push( new THREE.Vector4(  1,  1) );
			portal_geom.faces.push( new THREE.Face3( 0, 1, 2 ) );
			portal_geom.faces.push( new THREE.Face3( 2, 1, 3 ) );
			portal_geom.computeFaceNormals();
			var red_material = new THREE.MeshPhongMaterial({color: 0xFF0000});
			var blue_material = new THREE.MeshPhongMaterial({color: 0x0000FF});
			var portals = [
				new THREE.Mesh(portal_geom, blue_material),
				new THREE.Mesh(portal_geom, red_material)
			];
			portals[0].position = new THREE.Vector3(0, 0, -1);
			portals[1].position = new THREE.Vector3(-1, 0, 0);
			portals[1].rotation = new THREE.Vector3(0, 3.14*0.55, 0);
			main_scene.add(portals[0]);
			main_scene.add(portals[1]);
			
			//create the light
			var light = new THREE.PointLight(0xFFFFFF);
			light.position.set(0,1,2);
			main_scene.add(light);
			camera.position.z = 5;
			
			function portal_view(camera, src_portal, dst_portal) {
				var inverse_view_to_source = new THREE.Matrix4().getInverse(camera.matrix).multiply(src_portal.matrix);
				var new_mat = dst_portal.matrix.clone().multiply(inverse_view_to_source);
				new_mat.rotateY(3.14);
				return new_mat;
			}
			
			just_portal_0 = new THREE.Scene();
			just_portal_0.add(portals[0].clone());
			just_portal_0.add(light.clone());
			just_portal_0.__objects[0].scale.set(0.95,0.95,0.95);
			just_portal_0.__objects[0].z += 0.0001;

			
			//render & update loop
			function render() {
				
				requestAnimationFrame(render);//function(){console.log('ready')});
				cube.rotation.x += 0.1;
				cube.rotation.y += 0.1;
				var gl = renderer.context;
				
				//save original camera
				camera.updateMatrixWorld();
				orig_mat = camera.matrixWorld.clone();
				
				//clear the old scene
				renderer.autoClear=false;
				renderer.autoClear=false;
				renderer.autoClear=false;
				renderer.clear(true,true,true);
				
				//0. render the portal scenes.
				//0.a draw portal 0 as seen by the main camera into the stencil buffer, to clip its output.
				gl.colorMask(false,false,false,false); //disable the color buffer
				gl.depthMask(false); //and the depth buffer
				gl.enable(gl.STENCIL_TEST);
				gl.stencilMask(0xff);
				gl.stencilFunc(gl.NEVER,0,0xFF);
				gl.stencilOp(gl.INCR,gl.KEEP,gl.KEEP);
				renderer.render(just_portal_0,camera);
				gl.colorMask(true,true,true,true); //reenable
				gl.depthMask(true);
				gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);
				
				//render the view from portal 1 (seen through portal 0)
				//renderer.clear(false,true,false);
				gl.clear(gl.DEPTH_BUFFER_BIT);
				
				gl.stencilFunc(gl.LESS,0,0xff); //pass if 0 < stencil
				camera.matrixAutoUpdate = false;
				camera.matrixWorld = portal_view(camera, portals[0], portals[1]);
				renderer.render(main_scene, camera);
				gl.disable(gl.STENCIL_TEST);
				renderer.clear(false,false,true);
				
				
				
				//render the main scene.
				
				//1. reset the camera
				camera.matrixAutoUpdate = true;
				camera.matrixWorld = orig_mat.clone();
				
				//2. protect the portal view.
				//clear the depth buffer, and render the portal 0 shape to the depth buffer, so that it won't be overwritten by the main scene
				renderer.clear(false,true,false);
				
				//gl.colorMask(false,false,false,false); //disable the color buffer
				gl.colorMask(false,false,false,false);
				gl.depthMask(true);
				renderer.render(just_portal_0, camera);
				//return;
				gl.enable(gl.DEPTH_TEST);
				
				//3. render the actual main scene
				portals[0].position.z-=0.0001;
				gl.colorMask(true,true,true,true); //re-enable the color buffer
				renderer.render(main_scene, camera);
				portals[0].position.z+=0.0001;
			}
			render();
			
			document.addEventListener('mousemove', function(e) {
				camera.position.set(0,0,0);
				elevation = - 0.5*3.14 + 3.14 * e.clientY / window.innerHeight;
				rotation = -3.14 + 6.28 * e.clientX / window.innerWidth;
				camera.eulerOrder='YXZ';
				camera.rotation.set(elevation,rotation,0);
				camera.translateZ(2);
			});
		</script--> 
		
	</body> 
</html>